<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stump the Buff - v1.7</title>
  <style>
    /* BASIC STYLES */
    body {
      background: black;
      color: white;
      font-family: Rockwell, serif;
      margin: 0;
      padding: 20px;
      overflow-x: hidden;
    }
    h1, h2, h3, p {
      margin: 0 0 10px 0;
      text-align: center;
    }
    .center {
      text-align: center;
    }
    .hidden {
      display: none;
    }
    .version-number {
      text-align: center;
      font-size: 10px;
      opacity: 0.7;
      margin-top: 20px;
    }

    /* CONTAINERS */
    #intro-container, #game-container, #bonus-container, #final-container {
      max-width: 900px;
      margin: 0 auto;
    }
    #game-container, #bonus-container, #final-container {
      display: none; /* shown later */
    }

    /* INTRO SCREEN */
    #intro-difficulty {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .diff-btn {
      padding: 10px 20px;
      font-size: 16px;
      background: #222;
      border: 2px solid #FFD700;
      color: white;
      cursor: pointer;
    }
    .diff-btn:hover {
      background: #333;
    }
    #begin-btn {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background: #222;
      color: white;
      border: 2px solid #FFD700;
      cursor: pointer;
    }
    #begin-btn:disabled {
      border: 1px solid #444;
      cursor: not-allowed;
      color: #666;
    }

    /* TIMER CIRCLE */
    #timer-box {
      margin: 0 auto 10px auto;
      width: 160px;
      height: 160px;
      background-color: #222;
      border-radius: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      font-weight: bold;
      color: white;
      border: 2px solid #444; /* color changes dynamically */
      transition: all 0.2s ease;
    }

    /* CARDS & LAYOUT */
    .cards-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
      opacity: 1;
      transition: opacity 0.5s ease; /* fade effect for transitions */
    }
    .movie-card {
      width: 180px;
      border: 2px solid white;
      margin: 5px;
      padding: 10px;
      background-color: #000;
      position: relative;
      border-radius: 12px;
      min-height: 160px;
      transition: background-color 0.2s, border-color 0.2s;
    }
    .movie-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .movie-plot {
      font-size: 12px;
      margin-top: 5px;
      max-height: 80px;
      overflow-y: auto;
      opacity: 0.8;
    }
    .runtime-card {
      width: 100px;
      height: 60px;
      border-radius: 30px;
      background-color: #FFD700;
      color: black;
      font-weight: bold;
      border: 2px solid #FFD700;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 5px;
      cursor: grab;
    }

    /* BUTTONS */
    #joker-btn, #submit-btn, #continue-btn, #bonus-continue-btn {
      display: inline-block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background: #222;
      color: white;
      border: 2px solid #FFD700;
    }
    #joker-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* STATS BOXES */
    .stats-box {
      border: 1px solid #666;
      padding: 10px;
      margin: 10px auto;
      width: fit-content;
    }
    .midround-table {
      margin: 0 auto;
    }
    .midround-table td {
      padding: 5px 15px;
      text-align: center;
    }

    /* POPCORN EMOJIS */
    .popcorn-emoji {
      font-size: 24px;
      display: inline-block;
      margin: 0 2px;
    }

    /* CORRECT / INCORRECT ANIMATIONS */
    .correct {
      background-color: #003300 !important;
      border-color: #00FF00 !important;
      animation: pulse-green 0.5s;
    }
    .incorrect {
      background-color: #330000 !important;
      border-color: #FF0000 !important;
      animation: shake-red 0.5s;
    }

    @keyframes pulse-green {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @keyframes shake-red {
      0% { transform: translateX(0); }
      20% { transform: translateX(-3px); }
      40% { transform: translateX(3px); }
      60% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    /* FINAL & BONUS */
    #final-scores, #bonus-result {
      text-align: center;
      margin-bottom: 20px;
      font-size: 18px;
    }
    #final-cards-container {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      max-width: 900px;
      margin: 0 auto 20px auto;
    }
    .final-card {
      border-radius: 10px;
      border: 2px solid #666;
      padding: 10px;
      text-align: center;
    }
    .final-card.correct {
      background-color: #003300;
      border-color: #0f0;
    }
    .final-card.incorrect {
      background-color: #330000;
      border-color: #f00;
    }

    /* ROUNDED BUTTONS FOR SCORING */
    .rounded-button {
      border-radius: 20px;
      padding: 5px 10px;
      display: inline-block;
      color: #000;
      margin: 0 0 0 8px;
    }
  </style>
</head>
<body>
  <!-- INTRO SCREEN -->
  <div id="intro-container">
    <h1>Stump the Buff</h1>
    <p>
      You'll see 5 movie titles and 5 runtimes each round, from a filtered set based on difficulty.
      Drag each runtime onto the movie you think it belongs to.
      After 5 rounds, you'll see your score and can play a bonus round to gain extra points.
    </p>

    <!-- Difficulty Selection -->
    <div id="intro-difficulty">
      <button class="diff-btn" data-difficulty="easy">Easy</button>
      <button class="diff-btn" data-difficulty="medium">Medium</button>
      <button class="diff-btn" data-difficulty="hard">Hard</button>
    </div>

    <!-- Once difficulty is chosen, user can click "Begin" -->
    <button id="begin-btn" disabled>Loading...</button>
    <div class="version-number">V1.7</div>
  </div>

  <!-- MAIN GAME SCREEN -->
  <div id="game-container">
    <div id="timer-box">
      <span id="timer-value">20</span>
    </div>

    <!-- "This Round" Stats above the cards -->
    <div id="this-round-stats" class="stats-box"></div>

    <!-- Joker button -->
    <div class="center">
      <button id="joker-btn">Use Joker</button>
    </div>

    <!-- Movie & runtime cards -->
    <div id="movies-container" class="cards-container"></div>
    <div id="runtimes-container" class="cards-container"></div>

    <!-- "This Game" Stats below the cards -->
    <div id="this-game-stats" class="stats-box"></div>

    <!-- Submit button -->
    <div class="center">
      <button id="submit-btn">Submit</button>
    </div>
  </div>

  <!-- BONUS ROUND (Longest Movie) -->
  <div id="bonus-container">
    <h2>Bonus Round</h2>
    <p>Pick which of these 10 movies is the longest!</p>
    <div id="bonus-movies-container" class="cards-container"></div>
    <div id="bonus-result"></div>
    <div class="center">
      <button id="bonus-continue-btn">Continue</button>
    </div>
  </div>

  <!-- FINAL RESULTS SCREEN -->
  <div id="final-container">
    <h2>Game Over</h2>
    <p id="final-scores"></p>
    <div id="final-cards-container"></div>
    <div style="text-align:center; margin-bottom:10px;">
      <button id="share-twitter-btn">Share on Twitter</button>
      <button id="copy-recap-btn">Copy Recap</button>
    </div>
    <div style="text-align:center;">
      <button id="play-again-btn">Play Again?</button>
    </div>
  </div>

  <script>
    /***************************************
     * GLOBAL GAME STATE & CONFIGURATIONS  *
     ***************************************/
    const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vToIbm5XR9mtqOXHYzpF0jIXhGY9WI9m-QQak2KsZFB6CGVnRVRCPL3V6zFVbT6e_jLyGQM1e5XPjcX/pub?gid=131639577&single=true&output=csv";

    // Difficulty thresholds
    const DIFF_EASY = { rankMin: 0.75, strictMin: true };  // rank > 0.75
    const DIFF_MED  = { rankMin: 0.5, rankMax: 0.75 };
    const DIFF_HARD = { rankMax: 0.5, strictMax: true };   // rank < 0.5

    // Round timers per difficulty
    // e.g. Easy: 30 each round, Medium: 30 -> 25 -> 20 -> 15 -> 15, Hard: 20 -> 18 -> 15 -> 12 -> 10
    const TIMERS = {
      easy:   [30, 30, 30, 30, 30],
      medium: [30, 25, 20, 15, 15],
      hard:   [20, 18, 15, 12, 10]
    };

    // We might do a forced "Round 3 is a specific genre" example
    const FORCED_GENRE = "Comedy"; // just an example
    const FORCED_GENRE_ROUND = 3;  // i.e. the 3rd round (index=2) if possible

    let allMovies = [];
    let difficulty = null;
    let filteredMovies = []; // after applying difficulty filter
    let roundTimers = [];
    let currentRoundIndex = 0;

    // Each "round" is an array of 5 movie objects
    let rounds = [];

    // Stats
    let totalCorrect = 0;
    let totalDifference = 0; // sum of absolute diffs
    let totalAnswered = 0;
    let totalScore = 0; // new scoring system

    // Joker usage
    let jokerUsed = false;

    // Timers
    let timeLeft = 20;
    let roundTimer = null;
    let canDrag = false; // toggles whether dragging is allowed

    // For bonus round
    let bonusMovies = [];
    let bonusUsed = false;

    /***************************************
     * ON PAGE LOAD: FETCH & PARSE THE CSV *
     ***************************************/
    document.addEventListener("DOMContentLoaded", async () => {
      // Difficulty buttons
      document.querySelectorAll(".diff-btn").forEach(btn => {
        btn.addEventListener("click", e => {
          const chosen = e.target.getAttribute("data-difficulty");
          setDifficulty(chosen);
        });
      });

      // Begin button
      const beginBtn = document.getElementById("begin-btn");
      beginBtn.disabled = true;
      beginBtn.innerText = "Loading...";

      // Attempt to fetch
      try {
        await fetchCSV();
        beginBtn.disabled = false;
        beginBtn.innerText = "Begin";
      } catch(e) {
        console.error("Error fetching CSV:", e);
        beginBtn.innerText = "Error loading data";
      }

      beginBtn.addEventListener("click", onBeginGame);

      // Joker
      document.getElementById("joker-btn").addEventListener("click", useJoker);

      // Submit
      document.getElementById("submit-btn").addEventListener("click", onSubmitRound);

      // Bonus continue
      document.getElementById("bonus-continue-btn").addEventListener("click", onFinishBonus);

      // Final screen share & copy
      document.getElementById("share-twitter-btn").addEventListener("click", shareOnTwitter);
      document.getElementById("copy-recap-btn").addEventListener("click", copyRecap);

      // Play again
      document.getElementById("play-again-btn").addEventListener("click", resetGame);
    });

    async function fetchCSV() {
      const resp = await fetch(csvUrl);
      const data = await resp.text();
      parseCSV(data);
    }

    // We expect columns: "Movie Name", "runtime_minutes", "Runtime", "Plot", "Votes Percent Rank", "Genre" (optional)
    function parseCSV(csvData) {
      const lines = csvData.trim().split("\n");
      const headers = lines[0].split(",");

      // Indices
      const colMovieName = headers.indexOf("Movie Name");
      const colRuntimeMin = headers.indexOf("runtime_minutes");
      const colRuntime = headers.indexOf("Runtime");
      const colPlot = headers.indexOf("Plot");
      const colVotesRank = headers.indexOf("Votes Percent Rank");
      const colGenre = headers.indexOf("Genre"); // might be -1 if missing

      for (let i = 1; i < lines.length; i++) {
        const row = lines[i].split(",");
        let movie = {};

        movie["Movie Name"] = row[colMovieName]?.trim() || "";
        movie.runtime_minutes = parseInt(row[colRuntimeMin] || "0", 10);
        movie.Runtime = row[colRuntime]?.trim() || "";
        movie._plot = (row[colPlot] || "").replace(/['"]/g, "");
        movie._rank = parseFloat(row[colVotesRank] || "0"); // fraction
        if (colGenre >= 0) {
          movie.Genre = row[colGenre]?.trim() || "";
        } else {
          movie.Genre = "";
        }

        // For drag-drop
        movie._assignedRuntime = null;

        allMovies.push(movie);
      }
    }

    /****************************************
     * DIFFICULTY PICK & FILTERING THE LIST *
     ****************************************/
    function setDifficulty(chosen) {
      difficulty = chosen;
      // highlight chosen button, etc. (optional)
      document.querySelectorAll(".diff-btn").forEach(btn => {
        btn.style.background = (btn.getAttribute("data-difficulty") === chosen) ? "#444" : "#222";
      });
    }

    function filterByDifficulty() {
      if (!difficulty) return [];
      let range = { min: 0, max: 1 };

      // We interpret:
      // Easy: rank > 0.75
      // Medium: 0.5 <= rank <= 0.75
      // Hard: rank < 0.5
      if (difficulty === "easy") {
        // rank > 0.75
        return allMovies.filter(m => m._rank > 0.75);
      } else if (difficulty === "medium") {
        // 0.5 <= rank <= 0.75
        return allMovies.filter(m => m._rank >= 0.5 && m._rank <= 0.75);
      } else {
        // hard: rank < 0.5
        return allMovies.filter(m => m._rank < 0.5);
      }
    }

    /********************
     * START THE GAME   *
     ********************/
    function onBeginGame() {
      if (!difficulty) {
        alert("Please pick a difficulty first.");
        return;
      }
      // Hide intro, show game
      document.getElementById("intro-container").style.display = "none";
      document.getElementById("game-container").style.display = "block";

      resetGame(true);
    }

    // Clears state and starts Round 1
    function resetGame(skipUI = false) {
      // Stats
      currentRoundIndex = 0;
      totalCorrect = 0;
      totalDifference = 0;
      totalAnswered = 0;
      totalScore = 0;
      jokerUsed = false;
      bonusUsed = false;

      // Hide bonus/final
      document.getElementById("bonus-container").style.display = "none";
      document.getElementById("final-container").style.display = "none";

      // Filter & shuffle
      filteredMovies = filterByDifficulty();
      if (filteredMovies.length < 25) {
        alert("Not enough movies found for that difficulty!");
        // fallback: just use all?
        filteredMovies = allMovies.slice();
      }

      // Build 5 rounds
      buildRounds();

      // Set timers
      roundTimers = TIMERS[difficulty] || [20,20,20,20,20];

      // Start round
      startRound();
    }

    /***********************************************
     * BUILD ROUNDS (5 sets of 5), INCLUDING GENRE *
     ***********************************************/
    function buildRounds() {
      rounds = [];
      // shuffle a copy
      let pool = shuffle(filteredMovies.slice());

      // We try to force Round 3 = FORCED_GENRE if possible
      // We'll pick 5 from that genre for round 3 if available
      // Otherwise, we skip it
      const forcedGenreAvailable = pool.filter(m => m.Genre.includes(FORCED_GENRE)).length >= 5;

      // We'll create an array of 25 from the pool, but for Round 3 we might forcibly pick from a sub-pool
      let final25 = [];
      // pick first 2 rounds from top
      final25.push(...pool.slice(0, 10));
      pool.splice(0,10);

      // Round 3 forced if possible
      if (forcedGenreAvailable && pool.length >= 5) {
        const genrePool = pool.filter(m => m.Genre.includes(FORCED_GENRE));
        if (genrePool.length >= 5) {
          final25.push(...genrePool.slice(0,5));
          // remove them from the main pool
          genrePool.slice(0,5).forEach(m => {
            const idx = pool.indexOf(m);
            if (idx >= 0) pool.splice(idx,1);
          });
        } else {
          // fallback: just take next 5
          final25.push(...pool.slice(0,5));
          pool.splice(0,5);
        }
      } else {
        // no forced genre or not enough
        final25.push(...pool.slice(0,5));
        pool.splice(0,5);
      }

      // last 2 rounds
      final25.push(...pool.slice(0,10));

      // now we have 25
      // chunk into 5 sets
      for (let i = 0; i < 5; i++) {
        rounds.push(final25.slice(i*5, i*5 + 5));
      }
    }

    /*******************
     * START A ROUND   *
     *******************/
    function startRound() {
      if (currentRoundIndex >= 5) {
        // done with main rounds, go to bonus
        startBonusRound();
        return;
      }
      // Reset UI
      document.getElementById("joker-btn").disabled = jokerUsed; // only if used once
      document.getElementById("submit-btn").style.display = "block";

      // Clear any old color classes
      fadeOutCards(() => {
        renderRound(); // after fade out, fade in
      });
    }

    // Renders the round after a short fade
    function renderRound() {
      const roundMovies = rounds[currentRoundIndex];
      const moviesContainer = document.getElementById("movies-container");
      const runtimesContainer = document.getElementById("runtimes-container");

      moviesContainer.innerHTML = "";
      runtimesContainer.innerHTML = "";

      // Timer
      timeLeft = roundTimers[currentRoundIndex] || 20;
      setupTimer();

      // "This Round" and "This Game" stats
      updateThisRoundStats();
      updateThisGameStats();

      // Movie cards
      roundMovies.forEach(movie => {
        const card = document.createElement("div");
        card.classList.add("movie-card");
        card.setAttribute("data-correct", movie.runtime_minutes);

        card.innerHTML = `
          <div class="movie-title">${movie["Movie Name"]}</div>
          <div class="movie-plot">${movie._plot}</div>
        `;
        // drop events
        card.addEventListener("dragover", e => { if (canDrag) e.preventDefault(); });
        card.addEventListener("drop", e => dropHandler(e, movie, card));

        moviesContainer.appendChild(card);
      });

      // Runtimes
      const roundRuntimes = roundMovies.map(m => ({
        runtime: m.Runtime,
        runtime_minutes: m.runtime_minutes
      }));
      shuffle(roundRuntimes);

      roundRuntimes.forEach(rt => {
        const rc = document.createElement("div");
        rc.classList.add("runtime-card");
        rc.setAttribute("data-runtime", rt.runtime_minutes);
        rc.setAttribute("draggable", "true");
        rc.innerText = rt.runtime;

        rc.addEventListener("dragstart", e => {
          if (!canDrag) {
            e.preventDefault();
            return;
          }
          e.dataTransfer.setData("text/plain", rt.runtime_minutes.toString());
        });
        runtimesContainer.appendChild(rc);
      });

      // Fade in
      fadeInCards();
      canDrag = true;
    }

    // Timer logic
    function setupTimer() {
      clearInterval(roundTimer);
      const timerBox = document.getElementById("timer-box");
      const timerValue = document.getElementById("timer-value");

      timerValue.innerText = timeLeft;
      timerBox.style.color = "white";
      timerBox.style.borderColor = "#444";

      roundTimer = setInterval(() => {
        timeLeft--;
        timerValue.innerText = timeLeft;

        // color changes
        if (timeLeft <= 3) {
          timerBox.style.color = "red";
          timerBox.style.borderColor = "red";
        } else if (timeLeft <= 5) {
          timerBox.style.color = "orange";
          timerBox.style.borderColor = "orange";
        } else if (timeLeft <= 10) {
          timerBox.style.color = "yellow";
          timerBox.style.borderColor = "yellow";
        } else {
          timerBox.style.color = "white";
          timerBox.style.borderColor = "#444";
        }

        if (timeLeft <= 0) {
          clearInterval(roundTimer);
          onSubmitRound();
        }
      }, 1000);
    }

    /*********************
     * DRAG & DROP LOGIC *
     *********************/
    function dropHandler(e, movieObj, movieCard) {
      if (!canDrag) return;
      e.preventDefault();

      const data = e.dataTransfer.getData("text/plain");
      const allRuntimeCards = document.querySelectorAll(".runtime-card");
      let draggedCard = null;
      for (let c of allRuntimeCards) {
        if (c.getAttribute("data-runtime") === data) {
          draggedCard = c;
          break;
        }
      }
      if (!draggedCard) return;

      // if there's already a runtime here, put it back to container
      const container = document.getElementById("runtimes-container");
      const existing = movieCard.querySelector(".runtime-card");
      if (existing) {
        container.appendChild(existing);
      }

      movieCard.appendChild(draggedCard);
      // store assignment
      movieObj._assignedRuntime = parseInt(data, 10);
    }

    /*************************
     * SUBMIT & SCORING LOGIC *
     *************************/
    function onSubmitRound() {
      clearInterval(roundTimer);
      canDrag = false;
      document.getElementById("submit-btn").style.display = "none";

      // Evaluate the round
      const roundMovies = rounds[currentRoundIndex];
      let roundCorrect = 0;
      let roundDiff = 0;
      let answeredCount = 0;
      let sumActual = 0;

      const movieCards = document.getElementById("movies-container").children;
      for (let i = 0; i < movieCards.length; i++) {
        const card = movieCards[i];
        const correctRuntime = parseInt(card.getAttribute("data-correct"), 10);
        sumActual += correctRuntime;

        const assignedCard = card.querySelector(".runtime-card");
        if (assignedCard) {
          answeredCount++;
          const userRuntime = parseInt(assignedCard.getAttribute("data-runtime"), 10);
          if (userRuntime === correctRuntime) {
            roundCorrect++;
            card.classList.add("correct");
          } else {
            card.classList.add("incorrect");
          }
          roundDiff += Math.abs(userRuntime - correctRuntime);
        }
      }

      totalCorrect += roundCorrect;
      totalDifference += roundDiff;
      totalAnswered += answeredCount;

      // Calculate new scoring
      // baseScore = (#correct * 1000)
      const baseScore = roundCorrect * 1000;

      // average actual runtime
      const avgRuntime = sumActual / 5;
      // user avg difference
      const avgDiff = answeredCount ? roundDiff / answeredCount : avgRuntime; // if none answered, fraction=1
      const fraction = avgDiff / avgRuntime; // e.g. 0 => perfect, 1 => equal to avg
      const bonusFactor = (1 - fraction) ** 2; // squares the leftover fraction

      const roundScore = baseScore * (1 + bonusFactor);
      totalScore += roundScore;

      // show next round after short delay or user can just press "Continue"
      // We'll do a quick "Continue" button approach:
      updateThisRoundStats(roundCorrect, answeredCount, roundDiff, roundScore);
      updateThisGameStats();
      // We can let them see the color-coded results for a moment, then automatically continue
      // or just do it on button press. We'll do a small "Continue" approach:
      setTimeout(() => {
        currentRoundIndex++;
        startRound();
      }, 2000);
    }

    /****************************
     * "THIS ROUND" / "THIS GAME"
     ****************************/
    function updateThisRoundStats(rCorrect=0, ansCount=0, rDiff=0, rScore=0) {
      // If no arguments given, just show placeholders
      const container = document.getElementById("this-round-stats");

      if (rCorrect === 0 && ansCount === 0) {
        container.innerHTML = `<h3>This Round (Round ${currentRoundIndex+1} of 5)</h3>
          <p>Awaiting submission...</p>`;
        return;
      }
      const accuracyPercent = (rCorrect / 5) * 100;
      const skill = ansCount ? (rDiff / ansCount).toFixed(1) : "N/A";

      // partial popcorn for accuracy
      const popcornHTML = renderPopcorn(accuracyPercent);

      container.innerHTML = `
        <h3>This Round (Round ${currentRoundIndex+1} of 5)</h3>
        <table class="midround-table">
          <tr>
            <td><strong>Accuracy</strong></td>
            <td><strong>Skill</strong></td>
            <td><strong>Round Score</strong></td>
          </tr>
          <tr>
            <td>
              ${popcornHTML} ${accuracyPercent.toFixed(1)}% (${rCorrect}/5)
            </td>
            <td>${skill} min</td>
            <td>${rScore.toFixed(0)}</td>
          </tr>
        </table>
      `;
    }

    function updateThisGameStats() {
      const container = document.getElementById("this-game-stats");
      // how many total have we done so far
      const completed = (currentRoundIndex) * 5; // but we might call it after we finish a round
      // Actually, if we're calling after submission, we've done currentRoundIndex+1 rounds
      // so total possible is (currentRoundIndex+1)*5
      const totalPossible = (currentRoundIndex)*5; // updated after round ends in setTimeout
      // but let's do a small offset
      const actualPossible = (currentRoundIndex>0) ? (currentRoundIndex)*5 : 0;

      const userAccuracyPercent = actualPossible > 0 ? (totalCorrect / actualPossible) * 100 : 0;
      const userSkill = totalAnswered ? (totalDifference / totalAnswered) : 0;

      // partial popcorn
      const popcornHTML = renderPopcorn(userAccuracyPercent);

      container.innerHTML = `
        <h3>This Game (so far)</h3>
        <table class="midround-table">
          <tr>
            <td><strong>Accuracy</strong></td>
            <td><strong>Skill</strong></td>
            <td><strong>Total Score</strong></td>
          </tr>
          <tr>
            <td>
              ${popcornHTML} ${userAccuracyPercent.toFixed(1)}% (${totalCorrect}/${actualPossible})
            </td>
            <td>${userSkill.toFixed(1)} min</td>
            <td>${Math.round(totalScore)}</td>
          </tr>
        </table>
      `;
    }

    /****************************
     * JOKER LOGIC (ONE-TIME USE)
     ****************************/
    function useJoker() {
      if (jokerUsed) return;
      jokerUsed = true;
      document.getElementById("joker-btn").disabled = true;

      // Sort the 5 movies by runtime descending, highlight them with 5 green shades
      const roundMovies = rounds[currentRoundIndex];
      const sorted = [...roundMovies].sort((a,b) => b.runtime_minutes - a.runtime_minutes);

      // We define 5 green shades from darkest to lightest
      const greenShades = ["#003300", "#006600", "#009900", "#00CC00", "#00FF00"];

      // We'll store the original BG to revert later
      let originalStyles = [];

      // Apply highlight
      sorted.forEach((movie, idx) => {
        const card = findMovieCard(movie["Movie Name"]);
        if (!card) return;
        originalStyles.push({ card, bg: card.style.backgroundColor, bc: card.style.borderColor });

        card.style.backgroundColor = greenShades[idx];
        card.style.borderColor = greenShades[idx];
      });

      // After 5 seconds, revert
      setTimeout(() => {
        originalStyles.forEach(item => {
          item.card.style.backgroundColor = "#000";
          item.card.style.borderColor = "white";
        });
      }, 5000);
    }

    function findMovieCard(movieName) {
      const cards = document.querySelectorAll("#movies-container .movie-card");
      for (let c of cards) {
        const titleEl = c.querySelector(".movie-title");
        if (titleEl && titleEl.innerText === movieName) {
          return c;
        }
      }
      return null;
    }

    /********************************
     * BONUS ROUND: "Longest Movie" *
     ********************************/
    function startBonusRound() {
      document.getElementById("game-container").style.display = "none";
      document.getElementById("bonus-container").style.display = "block";

      // pick 10 from the same filteredMovies
      const pool = shuffle(filteredMovies.slice());
      bonusMovies = pool.slice(0, 10);

      // render them
      const container = document.getElementById("bonus-movies-container");
      container.innerHTML = "";
      bonusMovies.forEach(movie => {
        const card = document.createElement("div");
        card.classList.add("movie-card");
        card.style.cursor = "pointer";
        card.innerHTML = `
          <div class="movie-title">${movie["Movie Name"]}</div>
          <div class="movie-plot">${movie._plot}</div>
          <div style="margin-top:5px;">${movie.Runtime}</div>
        `;
        card.addEventListener("click", () => pickBonusMovie(movie, card));
        container.appendChild(card);
      });
    }

    function pickBonusMovie(chosenMovie, chosenCard) {
      if (bonusUsed) return; // only pick once
      bonusUsed = true;

      // find the actual longest
      let maxRuntime = -1;
      bonusMovies.forEach(m => {
        if (m.runtime_minutes > maxRuntime) maxRuntime = m.runtime_minutes;
      });
      const correct = (chosenMovie.runtime_minutes === maxRuntime);

      chosenCard.classList.add(correct ? "correct" : "incorrect");
      if (correct) {
        totalScore += 1000; // add bonus
      }

      document.getElementById("bonus-result").innerText = correct
        ? "Correct! You got +1000 points."
        : "Sorry, that wasn't the longest.";

      // highlight the actual longest card
      bonusMovies.forEach(m => {
        if (m.runtime_minutes === maxRuntime && m !== chosenMovie) {
          const c = findBonusCard(m["Movie Name"]);
          if (c) c.classList.add("correct");
        }
      });
    }

    function findBonusCard(name) {
      const container = document.getElementById("bonus-movies-container");
      const cards = container.querySelectorAll(".movie-card");
      for (let c of cards) {
        const titleEl = c.querySelector(".movie-title");
        if (titleEl && titleEl.innerText === name) {
          return c;
        }
      }
      return null;
    }

    function onFinishBonus() {
      // go to final scoreboard
      document.getElementById("bonus-container").style.display = "none";
      showFinalScreen();
    }

    /**************************
     * FINAL SCORE & RECAP    *
     **************************/
    function showFinalScreen() {
      document.getElementById("final-container").style.display = "block";

      const accuracy = (totalCorrect / 25) * 100;
      const skill = totalAnswered ? (totalDifference / totalAnswered) : 0;

      // Show final scoreboard text
      const finalScoresEl = document.getElementById("final-scores");
      finalScoresEl.innerText =
        `Final Accuracy: ${accuracy.toFixed(1)}% (${totalCorrect}/25) | ` +
        `Skill: ${skill.toFixed(1)} avg diff | ` +
        `Total Score: ${Math.round(totalScore)}`;

      // Show the final 25 movies with correct/incorrect
      const finalCardsContainer = document.getElementById("final-cards-container");
      finalCardsContainer.innerHTML = "";
      const allRounds = rounds.flat();
      allRounds.forEach(movie => {
        const actual = movie.runtime_minutes;
        const assigned = (movie._assignedRuntime !== null) ? movie._assignedRuntime : "-";
        const isCorrect = (assigned === actual);

        const card = document.createElement("div");
        card.classList.add("final-card");
        if (assigned !== "-") {
          card.classList.add(isCorrect ? "correct" : "incorrect");
        }
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:5px;">${movie["Movie Name"]}</div>
          <div>Actual: ${movie.Runtime}</div>
          <div>Your Pick: ${assigned === "-" ? "-" : assigned + " min"}</div>
        `;
        finalCardsContainer.appendChild(card);
      });
    }

    /************************************
     * SHARE ON TWITTER / COPY TO CLIPBOARD
     ************************************/
    function shareOnTwitter() {
      const accuracy = (totalCorrect / 25) * 100;
      const skill = totalAnswered ? (totalDifference / totalAnswered) : 0;
      const text = `I just scored ${Math.round(totalScore)} points in Stump the Buff! 
Accuracy: ${accuracy.toFixed(1)}% (${totalCorrect}/25)
Skill diff: ${skill.toFixed(1)} 
Try it yourself!`;

      const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
      window.open(url, "_blank");
    }

    function copyRecap() {
      const accuracy = (totalCorrect / 25) * 100;
      const skill = totalAnswered ? (totalDifference / totalAnswered) : 0;
      const text = `Stump the Buff Recap:
Score: ${Math.round(totalScore)}
Accuracy: ${accuracy.toFixed(1)}% (${totalCorrect}/25)
Skill diff: ${skill.toFixed(1)} 
Think you can beat me?`;

      navigator.clipboard.writeText(text).then(() => {
        alert("Recap copied to clipboard!");
      });
    }

    /*********************************
     * FADE TRANSITIONS FOR THE CARDS
     *********************************/
    function fadeOutCards(callback) {
      const mc = document.getElementById("movies-container");
      const rc = document.getElementById("runtimes-container");
      mc.style.opacity = "1";
      rc.style.opacity = "1";
      mc.offsetHeight; // force reflow
      mc.style.opacity = "0";
      rc.style.opacity = "0";
      setTimeout(() => {
        callback();
      }, 500);
    }

    function fadeInCards() {
      const mc = document.getElementById("movies-container");
      const rc = document.getElementById("runtimes-container");
      mc.style.opacity = "0";
      rc.style.opacity = "0";
      mc.offsetHeight; // reflow
      mc.style.opacity = "1";
      rc.style.opacity = "1";
    }

    /*******************************
     * POPCORN RATING (PARTIAL)    *
     *******************************/
    function renderPopcorn(accuracyPercent) {
      // rating out of 5
      const ratingOutOf5 = (accuracyPercent / 100) * 5;
      const full = Math.floor(ratingOutOf5);
      const frac = ratingOutOf5 - full;
      let html = "";
      for (let i = 0; i < full; i++) {
        html += "🍿";
      }
      if (frac > 0) {
        // partial
        html += "🍿"; 
      }
      return html + " ";
    }

    /*****************************
     * SHUFFLE UTILITY           *
     *****************************/
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
  </script>
</body>
</html>
