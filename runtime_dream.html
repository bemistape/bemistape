<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Runtime Dream</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      width: 100%; height: 100%;
      background: #000;
      font-family: sans-serif;
    }
    #zoom-container {
      position: relative;
      width: 100%;
      height: 100%;
      /* Slow zoom in/out */
      animation: slowZoom 15s ease-in-out infinite alternate;
      overflow: hidden;
    }
    /* Keyframes for slow zoom */
    @keyframes slowZoom {
      0%   { transform: scale(1); }
      100% { transform: scale(1.1); }
    }

    #container {
      position: absolute;
      width: 100%; height: 100%;
      top: 0; left: 0;
    }

    /* Basic styling for movie groups */
    .movie-group {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
      /* Start fully visible; we‚Äôll handle fade manually */
      opacity: 1;
      /* Random color/filter transformations added via JS */
      transition: filter 2s linear, opacity 1s ease-out;
    }

    .poster {
      width: 120px;
      border: 3px solid #fff;
      transition: transform 1.5s ease-in-out;
    }

    /* The runtime button with ‚Äútime warp‚Äù swirl effect */
    .runtime-btn {
      margin-top: -5px;
      background: #ff6347;
      color: #fff;
      border: none;
      padding: 5px 10px;
      font-size: 0.8rem;
      border-radius: 5px;
      position: relative;
      animation: timeWarp 4s ease-in-out infinite;
      pointer-events: none;
    }
    /* Simple wave (swirl) effect on runtime text */
    @keyframes timeWarp {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(3deg) scale(1.05); }
    }

    /* Flicker / glitch effect for runtime text */
    .runtime-glitch {
      animation: glitchText 1s steps(2, end) 1;
    }
    @keyframes glitchText {
      0% { opacity: 0; }
      50% { opacity: 1; }
      100% { opacity: 1; }
    }

    /* Emoji styling */
    .emoji {
      position: absolute;
      font-size: 2rem;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1s ease-out;
    }

    /* Fragment ‚Äúshards‚Äù from posters on fade-out */
    .poster-shard {
      position: absolute;
      width: 40px;
      height: 40px;
      overflow: hidden;
      background-repeat: no-repeat;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1s ease-out;
    }
  </style>
</head>
<body>
  <!-- Background MIDI audio -->
  <audio src="Casablanca.mid" autoplay loop>
    Your browser does not support the audio element.
  </audio>

  <div id="zoom-container">
    <div id="container"></div>
  </div>

  <script>
    // Simple CSV parser (no commas in fields assumed)
    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const header = lines.shift().split(',');
      return lines.map(line => {
        const cols = line.split(',');
        let obj = {};
        header.forEach((key, idx) => {
          obj[key.trim()] = cols[idx] ? cols[idx].trim() : "";
        });
        return obj;
      });
    }

    // Global arrays to track movies, their DOM elements, and basic positions for collisions
    let allGroups = [];

    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vToIbm5XR9mtqOXHYzpF0jIXhGY9WI9m-QQak2KsZFB6CGVnRVRCPL3V6zFVbT6e_jLyGQM1e5XPjcX/pub?gid=534697964&single=true&output=csv')
      .then(resp => resp.text())
      .then(data => {
        const movies = parseCSV(data);
        const container = document.getElementById('container');

        // Create a random color/filter effect
        function randomFilter() {
          const hue = Math.floor(Math.random() * 360);
          const sat = 50 + Math.floor(Math.random() * 50);
          const bright = 70 + Math.floor(Math.random() * 30);
          return `hue-rotate(${hue}deg) saturate(${sat}%) brightness(${bright}%)`;
        }

        // Create fragmentation shards for fade-out
        function fragmentPoster(posterElem, x, y) {
          const shardCount = 6; // arbitrary
          for(let i=0; i<shardCount; i++){
            const shard = document.createElement('div');
            shard.className = 'poster-shard';
            // Each shard is 40x40, so if the poster is 120 wide, we can cover 3 shards across, 4 down, etc.
            // We'll place them around the original poster position, with random offsets
            const offsetX = (Math.random() - 0.5) * 80; // random drift
            const offsetY = (Math.random() - 0.5) * 80;
            shard.style.left = (x + offsetX) + 'px';
            shard.style.top = (y + offsetY) + 'px';
            shard.style.backgroundImage = `url(${posterElem.src})`;
            shard.style.backgroundSize = `120px auto`;
            // Clip a random portion of the poster
            const bx = Math.random() * 80;
            const by = Math.random() * 80;
            shard.style.backgroundPosition = `-${bx}px -${by}px`;
            container.appendChild(shard);

            // Animate shards away
            setTimeout(() => {
              shard.style.opacity = 0;
            }, 50);
            setTimeout(() => {
              if(shard.parentNode) shard.parentNode.removeChild(shard);
            }, 1050);
          }
        }

        // Create chaotic collisions: store positions, do basic overlap checks, shift if needed
        function avoidCollisions(g) {
          const threshold = 100; // approximate bounding box size
          allGroups.forEach(other => {
            if(other === g) return;
            const dx = g.x - other.x;
            const dy = g.y - other.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < threshold) {
              // shift them apart
              const angle = Math.atan2(dy, dx);
              const push = (threshold - dist) / 2;
              g.x += Math.cos(angle) * push;
              g.y += Math.sin(angle) * push;
              other.x -= Math.cos(angle) * push;
              other.y -= Math.sin(angle) * push;
            }
          });
        }

        // Randomly glitch the runtime text
        function glitchRuntime(runtimeElem, originalText) {
          if(Math.random() < 0.2) { // 20% chance to glitch
            runtimeElem.classList.add('runtime-glitch');
            const oldText = runtimeElem.innerText;
            // Randomly show weird text
            runtimeElem.innerText = Math.random() < 0.5 ? '‚àû min' : (Math.floor(Math.random()*(-10)) + ' min');
            setTimeout(() => {
              runtimeElem.innerText = originalText;
            }, 500);
            setTimeout(() => {
              runtimeElem.classList.remove('runtime-glitch');
            }, 1000);
          }
        }

        function createMovieGroup() {
          if(!movies.length) return;
          const movie = movies[Math.floor(Math.random() * movies.length)];

          // group object
          let g = {
            el: document.createElement('div'),
            x: Math.random() * (window.innerWidth - 200),
            y: Math.random() * (window.innerHeight - 200),
            vx: (Math.random() - 0.5) * 1.2, // slow drift
            vy: (Math.random() - 0.5) * 1.2,
          };
          g.el.className = 'movie-group';
          container.appendChild(g.el);

          // Poster
          const posterElem = document.createElement('img');
          posterElem.src = movie.poster;
          posterElem.alt = movie.title;
          posterElem.className = 'poster';
          g.el.appendChild(posterElem);

          // Runtime
          const runtimeElem = document.createElement('button');
          runtimeElem.className = 'runtime-btn';
          const runtimeText = movie.runtime + ' min';
          runtimeElem.innerText = runtimeText;
          g.el.appendChild(runtimeElem);

          // Apply a random filter for the weird color shift
          g.el.style.filter = randomFilter();

          // Position the group
          g.el.style.left = g.x + 'px';
          g.el.style.top = g.y + 'px';

          // Occasionally glitch
          glitchRuntime(runtimeElem, runtimeText);

          // Store in global array
          allGroups.push(g);

          // Fade out after some time
          setTimeout(() => {
            // Fragmentation
            const rect = posterElem.getBoundingClientRect();
            fragmentPoster(posterElem, rect.left, rect.top);
            g.el.style.opacity = 0;
            setTimeout(() => {
              if(g.el.parentNode) g.el.parentNode.removeChild(g.el);
              const idx = allGroups.indexOf(g);
              if(idx !== -1) allGroups.splice(idx, 1);
            }, 1000);
          }, 12000); // keep it on screen for ~12s
        }

        // Create emojis too
        function createEmoji() {
          const emojis = ['üçø','üé¨'];
          const e = document.createElement('div');
          e.className = 'emoji';
          e.innerText = emojis[Math.floor(Math.random()*emojis.length)];
          container.appendChild(e);

          const ex = Math.random() * (window.innerWidth - 50);
          const ey = Math.random() * (window.innerHeight - 50);
          e.style.left = ex + 'px';
          e.style.top = ey + 'px';

          // Fade after a while
          setTimeout(() => {
            e.style.opacity = 0;
          }, 4000);
          setTimeout(() => {
            if(e.parentNode) e.parentNode.removeChild(e);
          }, 5000);
        }

        // Basic movement loop for collisions & drifting
        function animate() {
          allGroups.forEach(g => {
            g.x += g.vx;
            g.y += g.vy;
            // bounce off edges
            if(g.x < 0 || g.x > window.innerWidth - 150) g.vx *= -1;
            if(g.y < 0 || g.y > window.innerHeight - 150) g.vy *= -1;
            // attempt collisions
            avoidCollisions(g);

            // apply updated position
            g.el.style.left = g.x + 'px';
            g.el.style.top = g.y + 'px';
          });
          requestAnimationFrame(animate);
        }

        // Start intervals
        setInterval(createMovieGroup, 1000);
        setInterval(createEmoji, 2000);

        // Kick off movement
        animate();
      })
      .catch(err => console.error(err));
  </script>
</body>
</html>
