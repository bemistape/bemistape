<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Runtime Dream</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      width: 100%;
      height: 100%;
      font-family: sans-serif;
    }
    #container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    /* Common styling for posters, runtime buttons, and emojis */
    .movie-group, .emoji {
      position: absolute;
      pointer-events: none;
      opacity: 1;
    }
    /* Poster image */
    .poster {
      display: block;
      width: 150px;
      border: 3px solid #fff;
    }
    /* Runtime button styling */
    .runtime-btn {
      background: #ff6347;
      color: #fff;
      border: none;
      padding: 5px 10px;
      font-size: 0.9em;
      border-radius: 5px;
      position: absolute;
      top: calc(100% - 30px);
      left: 0;
      width: 100%;
    }
    /* Emoji styling */
    .emoji {
      font-size: 2rem;
    }
    /* Cloud-like floating animation (applied continuously) */
    @keyframes floatCloud {
      0% { transform: translate(0,0); }
      50% { transform: translate(10px, -10px); }
      100% { transform: translate(0,0); }
    }
    .float {
      animation: floatCloud 10s infinite ease-in-out;
    }
    /* Streak effect for moving elements */
    .streak {
      filter: blur(3px);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    // Basic CSV parser (assumes no commas inside fields)
    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const header = lines.shift().split(',');
      return lines.map(line => {
        const cols = line.split(',');
        let obj = {};
        header.forEach((key, idx) => {
          obj[key.trim()] = cols[idx] ? cols[idx].trim() : "";
        });
        return obj;
      });
    }

    fetch('https://docs.google.com/spreadsheets/d/e/2PACX-1vToIbm5XR9mtqOXHYzpF0jIXhGY9WI9m-QQak2KsZFB6CGVnRVRCPL3V6zFVbT6e_jLyGQM1e5XPjcX/pub?gid=534697964&single=true&output=csv')
      .then(response => response.text())
      .then(data => {
        const movies = parseCSV(data);
        const container = document.getElementById('container');

        function createMovieGroup() {
          if (!movies.length) return;
          const movie = movies[Math.floor(Math.random() * movies.length)];

          // Random starting positions for poster and runtime button
          const posterX = Math.random() * 80 + 10;
          const posterY = Math.random() * 80 + 10;
          const runtimeX = Math.random() * 80 + 10;
          const runtimeY = Math.random() * 80 + 10;

          // Create a group container for the movie elements
          const group = document.createElement('div');
          group.className = 'movie-group float streak';
          // Starting position (we'll use the poster's position initially)
          group.style.left = posterX + '%';
          group.style.top = posterY + '%';
          // Each group gets a random final scale between 0.7 and 1.3
          const finalScale = (0.7 + Math.random() * 0.6).toFixed(2);

          // Create poster element
          const posterElem = document.createElement('img');
          posterElem.src = movie.poster;
          posterElem.alt = movie.title;
          posterElem.className = 'poster';
          // Position inside group: we'll position runtime separately
          group.appendChild(posterElem);

          // Create runtime button element
          const runtimeElem = document.createElement('button');
          runtimeElem.className = 'runtime-btn';
          runtimeElem.innerText = movie.runtime + ' min';
          // Position runtime element below the poster
          group.appendChild(runtimeElem);

          // Append group to container
          container.appendChild(group);

          // Determine midpoint for the group by averaging poster and runtime start positions
          const joinX = (posterX + runtimeX) / 2;
          const joinY = (posterY + runtimeY) / 2;

          // Animation steps:
          // 1. After 1s, animate group to move from initial (posterX, posterY) to join (joinX, joinY) over 2s.
          // 2. Then over 3s, slowly drift to a new random nearby offset.
          // 3. Finally, fade out over 1.5s and remove.
          setTimeout(() => {
            group.style.transition = 'left 2s ease-out, top 2s ease-out';
            group.style.left = joinX + '%';
            group.style.top = joinY + '%';
          }, 1000);

          setTimeout(() => {
            // Determine a slight drift offset (up to ±5%)
            const driftX = joinX + (Math.random() * 10 - 5);
            const driftY = joinY + (Math.random() * 10 - 5);
            group.style.transition = 'left 3s linear, top 3s linear';
            group.style.left = driftX + '%';
            group.style.top = driftY + '%';
          }, 3000);

          // At the same time, remove the streak (blur) effect and apply the final scale.
          setTimeout(() => {
            group.classList.remove('streak');
            group.style.transition = 'transform 1s ease-out';
            group.style.transform = 'scale(' + finalScale + ')';
          }, 3000);

          // Fade out after slow crawl finishes
          setTimeout(() => {
            group.style.transition = 'opacity 1.5s ease-out';
            group.style.opacity = 0;
          }, 6000);

          // Finally, remove the element from the DOM
          setTimeout(() => {
            if (group.parentNode === container) container.removeChild(group);
          }, 7500);
        }

        // Create emoji elements
        function createEmoji() {
          const emojis = ['🍿', '🎬'];
          const emoji = emojis[Math.floor(Math.random() * emojis.length)];
          const emojiElem = document.createElement('div');
          emojiElem.className = 'emoji float streak';
          emojiElem.innerText = emoji;
          // Random starting position
          const startX = Math.random() * 80 + 10;
          const startY = Math.random() * 80 + 10;
          emojiElem.style.left = startX + '%';
          emojiElem.style.top = startY + '%';
          container.appendChild(emojiElem);

          // Slow drift for emoji as well
          setTimeout(() => {
            const driftX = startX + (Math.random() * 10 - 5);
            const driftY = startY + (Math.random() * 10 - 5);
            emojiElem.style.transition = 'left 3s linear, top 3s linear';
            emojiElem.style.left = driftX + '%';
            emojiElem.style.top = driftY + '%';
            emojiElem.classList.remove('streak');
          }, 1000);

          // Fade out
          setTimeout(() => {
            emojiElem.style.transition = 'opacity 1.5s ease-out';
            emojiElem.style.opacity = 0;
          }, 4000);
          setTimeout(() => {
            if (emojiElem.parentNode === container) container.removeChild(emojiElem);
          }, 5500);
        }

        // Increase density by reducing intervals
        setInterval(createMovieGroup, 600);
        setInterval(createEmoji, 1200);
      })
      .catch(err => console.error('Error loading CSV:', err));
  </script>
</body>
</html>
